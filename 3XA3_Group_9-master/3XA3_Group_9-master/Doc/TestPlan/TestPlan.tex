\documentclass[12pt, titlepage]{article}

\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{soul,xcolor}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}
\usepackage[round]{natbib}

\title{SE 3XA3: Test Plan\\Ratava}

\author{Team 9, Makiam Group
    \\ Aidan McPheilm - mcpheima
		\\ Alexie McDonald - mcdona16
		\\ Illya Pilipenko  - pilipeni
}

\date{\today}

\begin{document}
\setstcolor{red}

\maketitle

\pagenumbering{roman}
\tableofcontents
\listoftables
\listoffigures

\begin{table}[bp]
\caption{\bf Revision History}
\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\hline
{\bf Date} & {\bf Version} & {\bf Notes}\\
\hline
2018-09-18 & 0.0 & Added basic file\\
2018-10-26 & 1.0 & Added sections 5, 6, 7\\
2018-10-26 & 1.1 & Added sections 1, 2 and revision history\\
2018-10-26 & 1.2 & Added functional and non-functional test cases\\
2018-12-03 & 1.3 & Updated team name\\
\textcolor{red}{2018-12-05} & \textcolor{red}{1.3} & \textcolor{red}{Modified test cases}\\
\hline
\end{tabularx}
\end{table}

\newpage

\pagenumbering{arabic}

\section{General Information}

\subsection{Purpose}
The purpose of this document is to have comprehensive documentation for the testing of
the software that can be referred to and updated as needed.

\subsection{Scope}
The project is pretty simple mechanically, with the largest complexity being adding additional generation
options that otherwise reuse the hashing code. Therefore, the components the testing scope can cover are:
 General user interface usability, robustness with varying input, and output consistency when having consistent
 input.

\subsection{Acronyms, Abbreviations, and Symbols}

\begin{table}[hbp]
\caption{\textbf{Table of Abbreviations}} \label{Table}

\begin{tabularx}{\textwidth}{p{3cm}X}
\hline
\textbf{Abbreviation} & \textbf{Definition} \\
\hline
TDD & Test Driven Development\\
\hline
\end{tabularx}

\end{table}

\begin{table}[!htbp]
\caption{\textbf{Table of Definitions}} \label{Table}

\begin{tabularx}{\textwidth}{p{3cm}X}
\hline
\textbf{Term} & \textbf{Definition}\\
\hline
Test Driven Development & Unit test cases are written before the corresponding function is written.\\
Functional Test & A blackbox test which makes sure requirements are met.\\
Structural Test & A whitebox test which checks for errors and issues with implementation.\\
Dynamic Test & Testing that involves operating the software while it is running to check for issues.\\
Static Test & Testing that involves analyzing source code without running the software; opposite of Dynamic Test.\\
Manual Test & Testing software by means of individual cases, as opposed to automating it.\\
\hline
\end{tabularx}

\end{table}

\subsection{Overview of Document}

\section{Plan}

\subsection{Software Description}
The concept of the software is to take a user input string and generate an image file of an
avatar by using the input string as an input to a hashing function, for randomization.

\subsection{Test Team}
All source code developers and maintainers are in charge of testing, as we are implementing TDD.
This makes the test team be comprised of:
\begin{itemize}
  \item Aidain McPheilm
  \item Alexie McDonald
  \item Illya Pilipenko
\end{itemize}


\subsection{Automated Testing Approach}
We will be following the TDD approach.

\subsection{Testing Tools}
We will be doing our testing using pytest, as it's an easy yet effective testing tool for Python.

\subsection{Testing Schedule}

See Gantt Chart at the following url: \href{https://gitlab.cas.mcmaster.ca/pilipeni/3XA3_Group_9/blob/master/ProjectSchedule/3XA3GanttProject.gan}{Gantt Chart}

\section{System Test Description}

\subsection{Tests for Functional Requirements}

\subsubsection{Output Testing}

\paragraph{Output Test}

\begin{enumerate}

\item{\st{type-test}\textcolor{red}{test\_image\_output\_type}\\}


Type: \st{Manual}\textcolor{red}{Automated} functional

Initial State: The program is running and has generated an output image

Input: User inputs

Output: A lossy graphics file (.jpg)

How test will be performed: The image will be generated, the image's extension will be \st{examined, and it's ability to open with such an extension in an available image editor} \textcolor{red}{analyzed using the imghdr library and verified to be jpeg}

\item{\st{hash-out}\textcolor{red}{test\_generate\_hash\_is\_consistent}}

Type:\st{Manual}\textcolor{red}{Automated} functional

Initial State: The program is running and the user has entered the appropriate parameters

Input: hash encoding type and user string

Output: The hexadecimal output to the hash function

How test will be performed: The hash function will generate the output, then digest it. To ensure it is truly the output of a hash function, it will be passed through a third party hash analyzer in order to confirm it satisfies the three hash requirements

\item{set-qual}

Type: Manual functional

Initial State: The program is running and the user has been prompted to enter the parameters they wish to fix (if any)

Input: a set of parameters that should be fixed

Output: The hexadecimal output to the hash function

How test will be performed: The program will run and produce the output image. The iteration over the set will satisfy the following predicate: $(\forall i \in set\_of\_qualities \bullet (\exists j \in set\_of\_qualities\_output \bullet i = j)) $

\item{avatar-select}

Type: Manual functional

Initial State: The program is running and the user has been prompted to enter the parameters they wish to fix (if any)

Input: a template to follow

Output: A lossy graphics file (.jpg)

How test will be performed: The output image will be generated and opened. The following predicate should be satisfied: \\ $(\forall i | 0 \leq i < image\_width \bullet (\forall j | 0 \leq i < image\_height \bullet template[i][j] = image[i][j])) $

\item{string-hash}

Type: Manual functional

Initial State: The program is running and the user has been prompted to enter their preferred string to hash

Input: A user selected string

Output: The hexadecimal output to the hash function

How test will be performed: The hash function will be seeded and the output will be generated. The output given the exact same input string should be equal before digesting

\item{hash-type}

Type: Manual functional

Initial State: The program is running and the output to the hash function has been generated

Input: User inputs

Output: The hexadecimal output to the hash function

How test will be performed: The hash function will be seeded and the output will be generated. It will be digested, to ensure it is truly the output of that specific encoding, it will be passed through a third party hash analyzer in order to confirm that it is of that encoding.

\item{output-path}

Type: Manual functional

Initial State: The program is running and the user is prompted to enter the image output location

Input: A string representing the output file name and location

Output: Output image in the location specified and of that name

How test will be performed: The output image will be generated. The string representing the location and name will be compared to the location indicated by the file system

\item{help-doc}

Type: Manual functional

Initial State: The program is running

Input: A user action (button press) to open the help documentation

Output: Help documentation file opened

How test will be performed: The help button will be pressed by the user. The help documentation should open and be able to be read in it's entirety.

\item{image-show}

Type: Manual functional

Initial State: The program is running and the output image has been produced

Input: User inputs

Output: The generated image in an image editor program

How test will be performed: The image will be generated and will be opened in an available image editor/viewer within 0.5 seconds of image drawing completion. This metric will be timed.

\end{enumerate}

\subsection{Tests for Nonfunctional Requirements}

\subsubsection{Look and Feel Test}
\paragraph{Accessibility Test}
\begin{enumerate}

    \item {Accessible fonts test }

Type: Manual functional

Initial State: The program is running

Input: GUI font

Output: Verification of accessibility

How test will be performed: The qualities of the font will be compared with the web standards for accessibility
    \item {High contrast button test}

Type: Manual functional

Initial State: The program is running

Input: Button colour, font colour

Output: Contrast metric

How test will be performed: The colours will be put into WebAIM's contrast checker
    \item{Screen reader Test}

    Type: Manual functional

Initial State: The program is running

Input: Text on interface

Output: Screen reader audio

How test will be performed: A screen reader will be run and the output will be be evaluated on understandibility
\end{enumerate}
\subsubsection{Usability and Humanity Tests}
\paragraph{Ease of Use Test}
\begin{enumerate}
    \item{Usability Test\\}
    Type: Manual

Initial State: The program has started

Input: User input

Output: A lossy graphics file

How test will be performed: A sample of users will use the software without consulting the help documentation and their ease of use will be noted (85\% of users should use with ease)
\end{enumerate}
\subsection{Performance Requirements}
\begin{enumerate}
    \item {Speed Test (Random)}

    Type: Manual

Initial State: The program is running

Input: Input string, hash function

Output: Output image

How test will be performed: The program shall run given a set of user inputs and the duration shall be timed. It shall not exceed 5 seconds
    \item {Speed Test (Fixed)}

    Type: Manual

Initial State: The program is running

Input: Input string, hash function, set of fixed parameters

Output: Output image

How test will be performed: The program shall run given a set of user inputs and the duration shall be timed. It shall not exceed 5 seconds
\end{enumerate}
\subsubsection{Expected Technological Environment}
\begin{enumerate}
    \item {Environment test}
    Type: Manual

Initial State: The program is running

Input: User parameters

Output: Output image

How test will be performed: The program shall run on a set of different machines with a python3 compiler
\end{enumerate}

\subsection{Traceability Between Test Cases and Requirements}

In terms of traceability, many test cases and requirements have a one to one relationship.

\section{Tests for Proof of Concept}

\subsection{Generate Hash}

\paragraph{test\_retrieve\_hash\_algorithm\_returns\_correct\_hash}

\begin{enumerate}

\item{test-01\\}

Type: Dynamic

Initial State:

Input: 'sha256'

Output: hashlib.sha256

How test will be performed: Automatically by running test program containing all tests

\item{test-02\\}

Type: Dynamic

Initial State:

Input: 'md5'

Output: hashlib.md5

How test will be performed: Automatically by running test program containing all tests

\end{enumerate}



\paragraph{test\_generate\_hash\_is\_consistent}

\begin{enumerate}

\item{test-03\\}

Type: Dynamic

Initial State: hash\_val\_1 = GenerateHash.generate\_hash("test") \\
               hash\_val\_2 = GenerateHash.generate\_hash("test")

Input: hash\_val\_1 == hash\_val\_2

Output: true

How test will be performed: Automatically by running test program containing all tests

\end{enumerate}

\subsection{Use Hash}


\paragraph{test\_hex\_to\_rgb}

\begin{enumerate}

\item{test-04\\}

Type: Dynamic

Initial State:

Input: "ffffff"

Output: (255,255,255)

How test will be performed: Automatically by running test program containing all tests

\item{test-05\\}

Type: Dynamic

Initial State:

Input: "abcabc"

Output: (171, 202, 188)

How test will be performed: Automatically by running test program containing all tests

\end{enumerate}


\section{Comparison to Existing Implementation}

As there has been several new features added (as per the functional requirements), there is a more robust set of test cases. Tests for the GUI and for the new fixed parameters were the largest addition to the set.

\section{Unit Testing Plan}

\subsection{Unit testing of internal functions}
For the internal functions we will try, to the best of our ability, to implement TDD.
\\
For example with the function retrieve\_hash\_algorithm(has\_type) we would first write that header, and then write a test with an example input such as 'sha256' and then assert that for that input the output is equal to 'hashlib.sha256'.

\subsection{Unit testing of output files}
Unit testing of output files  is tricky but there is some things that can be done.

We will;
\begin{itemize}
    \item Check the resolution of the output file to make sure that it is what the user wanted it to be.
    \item Check the file type to make sure that it was exported in the correct format.
    \item Check the name of the file to ensure that it has the same name as the input string for the hash.
\end{itemize}

\bibliographystyle{plainnat}

\bibliography{SRS}

\newpage

\section{Appendix}

\subsection{Symbolic Parameters}
n/a

\subsection{Usability Survey Questions?}
\begin{itemize}
    \item How satisfied were you overall with using this software?
    \item How could the user interface be improved to make use of the software easier?
    \item How did you find the feedback from the software as you used it?
    \item Do you have any other comments?
\end{itemize}

\end{document}